---
layout: post
title: 「Apple文档」Threading Programming Guide之Run Loops
---
{{page.title}}
========================

Run Loop是与线程相关之基础设施的一部分。一个run loop就是一个事件处理循环，用于调度任务及协调到来事件的接收。run loop的目的是，在有工作要做时保持线程忙碌，当无事可做时让线程进入休眠状态。<br/>

Run Loop管理并非完全自动的。你仍(必)须设计线程的代码以便在合适的时间启动run loop并响应到来的事件。Cocoa和Core Foundation均提供run loop对象来助你配置和管理线程之run loop。你的应用程序无需显式地创建这些对象；包括应用程序之**主线程**在内的每个线程都有一个相关联的run loop对象。然而，只有辅助线程需显示地把它们的run loop运行起来。作为应用程序启动过程的一部分，应用程序框架会自动设置并于**主线程**之上运行run loop。<br/>

以下部分提供了关于run loop的更多信息，以及如何为应用程序配置它们。有关run loop对象的其它信息，可见[NSRunLoop Class Reference](https://developer.apple.com/documentation/foundation/nsrunloop)及[CFRunLoop Reference](https://developer.apple.com/documentation/corefoundation/cfrunloopref?language=objc)。<br/>

## 3.1 剖析Run Loop
其实，run loop字面本身就可以表达其意了。它是线程进入的一个循环，并用于运行事件处理程序(handler)来响应到来的事件。你的代码需提供用于实现run loop之实际循环部分的控制语句——换言之，你的代码提供驱动run loop所需的**while**或**for**循环。在循环内，使用run loop对象「运行」对应的事件处理代码，该代码接收事件并调用已安装的处理程序。<br/>

run loop从两种不同类型的源头接收事件。输入源(input source)传递异步事件，通常是来自另一个线程或另一不同应用程序的消息。定时器源(timer source)提供同步事件，它们在预定的时间或以重复的间隔发生。两种类型的源都使用特定于应用本身的处理程序来处理到来的事件。<br/>

图3-1展示了run loop的概念结构及各种输入源。输入源将异步事件传递给相应的处理程序(handler)，并触发`runUntilDate:`方法(在线程的关联`NSRunLoop`对象上调用)退出。定时器源将事件交付给它们的处理程序后，并不会导致run loop退出。<br/>

<img src="/images/posts/2021-10-06/Figure_3-1.png"> <br/>
除了处理输入源之外，run loop还生成有关run loop之行为的通知。已注册的run-loop观察者可以接收这些通知，并使用它们在线程上执行额外的处理工作。可利用**Core Foundation**在线程上安装run-loop观察者。<br/>

接下来的几节内容提供有关run loop之组件及其运行模式的更多信息，此外，还描述了事件处理期间在不同时间点生成的各类通知。<br/>

### 3.1.1 Run Loop模式
「run loop模式」是被监视的输入源和定时器之集合，以及要通知的run loop观察者之集合。每当运行你之run loop时，都要或显示或隐式地指定要运行的特定「模式」。在run loop的此过程中，只有与该「模式」相关的源(source)会被监听并允许传递其事件。(类似地，只有与该模式相关联的观察者才会被通知该run loop的进度情况。)与其它模式相关联的源将保留任意新事件，直至后续事件以适当的模式经由该loop。 <br/>

在代码中，你可以通过名字识别「模式」。Cocoa和Core Foundation都定义了一个默认「模式」和几个常用「模式」，以及用于在代码中指定这些「模式」的字符串。你可以通过简单地指定一个自定义字符串来定义自定义(custom)模式。虽然你为自定义「模式」分配的名称是任意的，但是，这些模式的内容却非任意为之。你必须确保将一个或多个输入源(input source)、定时器(timer)或run-loop观察者添加到你创建的「模式」中，如此，它们才能有用。<br/>

在通过run loop的特定过程中，你可以使用「模式」过滤掉那些不想要的事件源。大多数情况下，你会希望在系统定义的「default」模式下运行run loop。然而，modal面板可以在「modal」模式下运行。则在这种「模式」下，只有与modal面板相关的源才会将事件传递给线程。对于辅助线程，你可以使用自定义「模式」来阻止低优先级源(source)在时间紧要的操作期间传递事件。<br/>

**注意:**「模式」基于事件的来源而非事件的类型以进行区分。比如，你不会使用「模式」只匹配鼠标下拉事件或键盘事件。你可以使用「模式」监听不同的端口集、临时挂起的定时器、或者更改那些当前被监视的源(source)和run loop观察者。<br/>

Table 3-1列出了Cocoa和Core Foundation定义的标准模式、以及使用该模式时的说明。**Name列**列出了在代码中用于指定「模式」的实际常量。<br/>
<img src="/images/posts/2021-10-06/Table_3-1.png"> <br/>

### 3.1.2 输入源(source)
输入源将事件异步传递给线程。事件的源(source)取决于输入源的类型，通常为两种类型之一。基于端口(port-based)的输入源监视应用程序的**Mach**端口。自定义输入源(custom input source)监视自定义事件源。就你的run loop而言，输入源是基于端口的(port-based)还是自定义类型并不重要。系统通常会实现两种类型的输入源，你可以依原样使用。这两种信号源之间的唯一区别是它们发出信号的方式。基于端口的(port-based)的源由内核自动发出信号，而自定义源则必须手动从另一线程发出信号。<br/>

当你创建输入源时，将它分配给run loop的一个或多个模式(mode)。模式影响在任意给定时刻之受监视的输入源。大多数情况，你在**Default**模式下运行run loop，但是你也可以指定自定义模式。若输入源不在当前监视的模式中，则它生成的任意事件都将被保存，直到run loop以正确的模式运行为止。<br/>

接下来的部分将描述几类输入源。<br/>

#### 输入源之基于端口(port-based)源
Cocoa和Core Foundation为创建基于端口的输入源提供了内置支持，这些源需要使用与端口相关的对象和函数。例如，在Cocoa中，你根本不需要直接创建输入源。你只需要创建一个port对象，并使用`NSPort`的方法将该端口(port)添加到run loop中。port对象会为你处理所需输入源的创建和配置工作。<br/>

在Core Foundation中，你必须手动创建端口(port)及其run loop源。在此两种情况下，你都使用与端口不透明类型(`CFMachPortRef`、`CFMessagePortRef`或`CFSocketRef`)相关联的函数来创建合适的对象。<br/>

关于如何设置和配置基于端口(port-based)的自定义源之示例，见Configuring a Port-Based Input Source一节。<br/>

#### 输入源之自定义输入(custom input)源
要创建自定义输入源，你必须使用Core Foundation中与**CFRunLoopSourceRef**不透明类型相关联的函数。你可以使用多个回调(callback)函数配置自定义输入源。Core Foundation会在不同的时间点调用这些函数来配置源，处理任意传入之事件，并在从run loop中移除此源(source)时销毁它。<br/>

除了定义事件到达时自定义源之行为外，你还必须定义事件传递机制。源的这一部分运行在一个单独的线程上，负责向输入源提供它的数据，并在数据准备好运行处理时向它发出信号。事件传递机制取决于你，但不必过于复杂。<br/>

有关如何创建自定义输入源，见Defining a Custom Input Source。有关自定义输入源之参考内容，见CFRunLoopSource Reference。<br/>

#### 输入源之Cocoa Perform Selector源
除基于端口(port-based)的源之外，Cocoa还定义了一个自定义输入源，它许你在任意线程上执行选择器(selector)。同基于端口(port-based)源类似，执行选择器之请求会被序列化(serialized)到目标线程上，此举减轻了在一个线程上运行多个方法时可能出现的许多同步问题。与基于端口(port-based)的源不同，perform selector源在它执行完选择器之后会将自己从runloop中移除。<br/>

**注:**在OS X v10.5之前，perform selector源通常用于向**主线程**发送消息，但在OS X v10.5及其后续版本并iOS中，你可以使用它们向任意线程发送消息。<br/>

当在另一线程上执行选择器(selector)时，目标线程必须有一个活跃的run loop。对于你创建的线程，这意味着等待直至你的代码显式地启动run loop。然而，因为**主线程**会启动它自己的run loop，所以只要应用程序调用了其应用委托(delegate)的**applicationDidFinishLaunching:**方法，便可以在该线程上发出调用。run loop每次通过循环来处理所有排队的perform selector调用(请求)，而非在每次迭代期间处理一个。 <br/>

Table 3-2列出了在**NSObject**中定义的方法，这些方法可用于在其它线程上执行选择器(selector)。因为这些方法是在**NSObject**上声明的，所以你可在任何可以访问Object对象的线程中使用它们，包括**POSIX**线程。实际上，这些方法并不会创建一个执行选择器的新线程。<br/>
<img src="/images/posts/2021-10-06/Table_3-2.png"> <br/>

### 3.1.3 定时器(Timer)源
定时器源会在未来的预设时间同步地向你的线程传递事件。定时器是线程通知自己做某事的一种方式。比如，搜索字段可以使用定时器在用户连续击键之间经过一段时间后启动自动搜索。使用此延迟时间使**用户**有机会在开始搜索之前输入尽可能多的所需搜索字符串。<br/>

虽然定时器可以生成基于时间的通知，但是它并不是一种实时机制。像输入源一样，定时器与run loop之特定模式相关联。如果定时器不在当前被run loop监视的模式中，那么直到你在定时器支持的模式中运行run loop时才会触发它(定时器)。类似地，如果在run loop正执行一个处理程序(handler routine)时，定时器触发了，那么定时器则将等待到下一个通过run loop以调用它的处理程序(handler routine)。如果run loop根本没有运行，则定时器也永远不会被触发。<br/>

你可以将定时器配置为仅生成一次或重复生成事件。重复定时器会根据预定的触发时间而非实际的触发时间来自动重新调度自己。例如，如果某定时器被计划在特定时间点触发，并且之后每隔5秒触发一次，那么即使实际的触发时间被延迟了，计划的触发时间将始终落在最初的5秒时间间隔上。如果触发时间被延迟以至于错过了一个或多个预定的触发时间，则在错过的时间段内只触发一次。在触发错过的时间段之后，定时器将被重新调度到下一个预定的触发时间点。<br/>

有关配置定时器(timer)源的更多信息，见Configuring Timer Source。有关参考信息，可见NSTimer Class Reference或CFRunLoopTimer Reference。<br/>

### 3.1.4 Run Loop观察者
源在适当的异步或同步事件发生时触发，与之相反，run loop观察者于runloop本身执行期间在特定位置触发。你可以使用runloop观察者来准备线程以处理给定的事件，或者在线程进入休眠状态之前准备它。你可以将runloop观察者与runloop中的以下事件关联起来：<br/>

- 进入run loop时。<br/>
- 当run loop要处理定时器时。<br/>
- 当run loop要处理输入源时。<br/>
- 当run loop即将进入休眠状态时。<br/>
- 当run loop已唤醒，但卡在处理唤醒它的事件之前。<br/>
- 退出run loop时。<br/>

你可以利用Core Foundation将run-loop观察者添加到应用程序中。想创建一个run-loop观察者，你需要创建一个**CFRunLoopObserverRef**不透明类型的新实例。这种类型会跟踪你的自定义回调(callback)函数、以及它感兴趣的活动。<br/>

与定时器类似，run-loop观察者可使用单次或重复使用。单次观察者在触发后会将自己从run-loop中移除，而重复观察者会保持连接。在创建观察者时，你可以指定其为单次运行抑或重复运行。<br/>

有关如何创建runloop观察者的示例，可见Configuring the RunLoop一节。相关参考信息，可见CFRunLoopObserver Reference。<br/>

### 3.1.5 事件的Run Loop序列
每次运行它时，线程的run loop都会处理挂起的事件，并为任何附着的观察者生成通知。其操作顺序非常具体，如下所示：<br/>

- 1.通知观察者，已进入run loop。<br/>
- 2.通知观察者，任一就绪定时器即将被触发。<br/>
- 3.通知观察者，那些非基于端口(port-based)的输入源即将触发。<br/>
- 4.启动那些已准备启动之非基于端口的输入源。<br/>
- 5.如果基于端口(port-based)的输入源已准备就绪并等待触发，则立即处理该事件。转去步骤9。<br/>
- 6.通知观察者，线程即将睡(休)眠。<br/>
- 7.将线程置于睡(休)眠状态，直到有如下任一事件发生：<1>基于端口的输入源事件到达；<2>定时器启动；<3>为run loop设置的超时阈值已过期；<4> run loop被显式唤醒。<br/>
- 8.通知观察者，线程刚刚被唤醒。<br/>
- 9.处理那些挂起的事件。<1>如果触发了用户定义的定时器，则处理定时器事件并重启该loop，转去步骤2；<2>如果触发了输入源，则传递该事件；<3>如果run loop被显式唤醒但尚未超时，则重启该loop，转去步骤2。<br/>
- 10.通知观察者，已退出run loop。<br/>

因为针对定时器和输入源的观察者通知是在这些事件实际发生之前传递的，所以在通知的时间和实际事件的时间之间可能存在着差距。如果这些事件之间时间间隔是非常严苛的，你可以使用睡(休)眠和从睡(休)眠状态中醒来之通知来助你关联实际事件之间的时间间隔。<br/>

因为定时器和其它周期性事件都是在运行run loop时传递的，所以绕过该loop会中断这些事件的传递。每当通过进入loop并重复向应用程序请求事件来实现「鼠标跟踪」例程时，就会出现这种现象的典型示例。因为你的代码是直接捕获事件，而非让应用程序正常地分发这些事件，所以直到「鼠标跟踪」例程退出并将控制权返还给应用程序后，活跃态的定时器才能触发。<br/>

可以利用run loop对象显式唤醒run loop。其它事件也可能导致run loop被唤醒。例如，添加另一个非基于端口(non-port-based)之输入源会唤醒run loop，以便立即处理该输入源，而非等待其它事件发生。<br/>

## 3.2 你将何时使用Run Loop ?
唯一需要显式运行run loop之时是你为应用程序创建辅助线程的时候。应用程序**主线程**的run loop是基础设施的关键部分。因此，应用程序框架提供了运行主应用程序循环之代码，并自动启动该循环。**iOS**中的**UIApplication**(或**OS X**中的**NSApplication**)之`run`方法启动应用程序的主循环，即作为正常启动序列的一部分。如果你用**Xcode**模板项目来创建你的应用程序，你应该永远也无需显式地调用这些例程。<br/>

对于辅助线程，你需要决定run loop是否必要；如有必要，则自行配置并启动它。你无需在所有情形下都启动线程的run loop。例如，如果你需要使用一个线程来执行某个长时间运行的预定任务，那么你可能需尽量避免启动run loop。run loop适用于需要更多线程交互之情况。例如，若你计划执行以下任一操作，则需要启动run loop：<br/>

- 使用端口或自定义输入源同其它线程通信。<br/>
- 在线程上使用定时器。<br/>
- 在**Cocoa**应用程序内使用任一`performSelector...`方法。<br/>
- 让线程持续执行周期性任务。<br/>

如果你确定选择使用run loop，配置和设置工作其实是非常简单的。不过，与所有「线程编程」一样，你应该有一个在适当情况下退出辅助线程之计划。让线程干净利落地退出总比被强制终止要好得多。有关如何配置和退出run loop的信息，可见Using Run Loop Objects(使用Run Loop对象)一节。<br/>

<img src="/images/posts/2021-10-06/NSRunLoop_class.png"> <br/>
