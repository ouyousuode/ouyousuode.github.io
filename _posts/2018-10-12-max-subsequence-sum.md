---
layout: default
title: 求最大子序列和问题
---
{{page.title}}
====================

大四上学期参加学校招聘会，几番斟酌后，决定去做一名软件工程师。虽要从事软件开发，本专业却为电子信息工程，非科班，短板大。故于大四下学期(毕业前夕)购入一本《数据结构与算法分析——C语言描述》。但闲翻几页后，就束之高阁了。个中缘由，许是当时已无学习之心思。时隔多年，再次翻阅，甚是后悔“为什么当时没坚持读下去”。

开篇为一选择问题，“设有一组N个数而要确定其中第K个最大者”。针对此题，很普遍的思路：将这N个数读入一数组，再通过某种简单的算法，比如冒泡排序，以递减的顺序将数组元素排序，然后返回位置K上的元素。

或者，先把前k个元素读入数组，(以递减)对其排序，然后将剩余元素逐个读入。当新元素被读入时，如果它小于数组中的第k个元素，则忽略；否则，将其放入数组中正确的位置上，同时挤数组中的某个元素出数组。当算法终止时，位于第k个位置上的元素作为答案返回。

这两种算法的编码都还不复杂，但是我们会问：孰优孰劣？孰重孰轻？还是二者无优劣之分、轻重之别？使用含有一百万个随机元素的文件，在k=500000的条件下进行模拟发现，以上两种算法均需要计算机处理若干时长才能计算完(我并未模拟，此为作者的说明) ，这显然不是我们想得到的结果。在此问题中，空间复杂度显得不是那么重要；但是，时间复杂度却重要非常。当我们分析时间复杂度时，我们需要的是最坏情况下的运行时间。这又两方面的原因：其一，它对所有的输入提供了一个界限，包括特别坏的输入，而平均情况分析不提供这样的界限；其二，平均情况的界限计算起来通常困难得多。

接下来，即有趣的最大子序列和问题了。

<img src="/images/posts/2018-10-12/maxSubsequenceSum.jpg">
这个问题的吸引力在于，它有多种求解方式，而不同方式的时间复杂度又相差甚远。穷举法，是最容易想到的一种方法，即把所有子序列的和都列举出来，然后逐一比较便得结果。可参见此示意图：

<img src="/images/posts/2018-10-12/exhaustiveAttackMethod.jpg">
代码实现为：

<img src="/images/posts/2018-10-12/maxSubsequenceSum_01.jpg">
该算法的正确性毋庸置疑。其运行时间为O(N^3),这完全取决于第30和31行，第31行由一个含于三重嵌套for循环中的O(1)语句组成。第27行上的循环大小为N，第二个循环大小为N-i，它可能要小，但也可能是N。我们必须假设最坏的情况，而这可能会使得最终的界限有些大。第三个循环的大小为j-i+1，我们也假设它的大小为N。因此，总数为O(1.N.N.N)=O(N^3)。所以，我们可以简单地认为它的算法复杂度为N^3。
但是，

<img src="/images/posts/2018-10-12/exhaustiveAttackMethodVariant.jpg">
我们发现，第30和31行上的计算过分耗时了，所以将其优化为：

<img src="/images/posts/2018-10-12/maxSubSequenceSum_02.jpg">
大体思路：以数组[-2,11,-4,13,-5,-3]为例，先从元素-2开始向右找，计算这一轮可能的最大子序列和；再从元素11向右找，计算此轮可能的最大子序列和，依次类推...

对这个问题，还有一个递归和相对复杂度为O(N logN)的求解方式。如果没出现O(N)(线性的)求解方式，这个算法就会是体现递归成功的极好范例了。该算法采用的是一种“分治”策略。其思路是：把原问题分解成两个大致相等的子问题，然后递归地对它们求解，这是“分”部分；“治”阶段将两个子问题的解合并到一起并可能再做些少量的附加工作，最后得到原问题的解。

在我们的例子中，最大子序列和可能出现在三处：(1)出现在输入数据的左半部分 (2)出现在输入数据的右半部分 (3)跨越输入数据的中间从而占据左右两部分。

针对(1)(2)两种情形，可以递归求解。而情况(3)的最大和可以通过求出前半部分的最大和(包含前半部分的最后一个元素)以及后半部分的最大和(包含后半部分的第一个元素)，然后将两者相加来得到。

比如，输入4,-3,5,-2,-1,2,6,-2。其中前半部分的最大子序列之和为6(第1到第3)，后半部分到最大子序列和为8(第6到7)。包含最后一个元素的前半部分最大和为4(第1到4)，且后半部分包含第一个元素的最大和为7(第5到7)。因此，横跨着两部分且通过中间的最大和为4+7=11。其代码实现为：

<img src="/images/posts/2018-10-12/maxSubsequenceSum_03.jpg">
第76到82行处理基准情况，如果left == right，那么只有一个元素，并且当该元素非负时它就是最大和子序列。left > right的情况是不可能出现的。

第85和86行执行两次递归调用，可以观察到，递归调用总是对小于原问题的规模进行。第88到95行计算到达中间边界的左半部分之最大和。第97到104行计算从中间起的右半部分的最大和。然后，这两个最大和的和为扩展到左右两边到最大和。maxOfThree()函数返回三个参数中的最大值。

计算此算法的时间复杂度：令T(N)为求解大小为N的最大子序列和问题所花费的时间。如果N=1，则第76到82行花费某个时间常量，我们称之为1个时间单元。于是，T(1)=1。否则，程序必须进行两次递归调用，在第94到104行花费的时间为O(N)。除了第85和86行之外代码的工作时间为常量，与O(N)相较可被忽略不计。

其余就是这两个递归调用的工作了，而且此两行求解大小为N/2的子序列问题(假设N是偶数)。因此，这两行每行花费T(N/2)个时间单元，共花费2T(N/2)个时间单元。所以，

<img src="/images/posts/2018-10-12/timeFor_03.jpg">
此外，第四种算法为：

<img src="/images/posts/2018-10-12/maxSubsequenceSum_04.jpg">
很明显，此算法的时间复杂度为O(N)。

该算法的一个附带优点是：它只对数据进行一次扫描，一旦A[i]被读入并处理，它就不再被记忆。因此，如果数组在磁盘上，它可被顺序读入且不必在内存中存储数组的任何数据。

至此，不禁叹服此为一本好书。也难怪，它属于“计算机科学丛书”(机械工业出版社)。关于此，有介绍“自1998年开始，华章分社就将工作重点放在了遴选、移译国外优秀教材上。经过多年的不懈努力，与Person,McGraw-Hill,Elsevier,MIT,John Wiley&Sons,Cengage等世界著名出版公司建立了良好的合作关系，从他们现有的数百种教材中甄选出Andrew S.Tanenbaum，Bjarne Stoustrup，Brain W.Kernighan，Dennis Ritchie，Jim Gray，Afred V.Aho，John E.Hopcroft，Jeffrey D.Ullman，Larry L.Peterson等大师名家的一批经典作品”，以“计算机科学丛书”为总称出版，供读者学习、研究及珍藏。

关于读书，曾文正公讲“盖士人读书，第一要有志，第二要有识，第三要有恒。有志则不甘为下流；有识则知学问无尽，不敢以一得自足，如河伯之观海，如牛蛙之窥天，皆无识者也；有恒则断无不成之事。此三者缺一不可”。

要读经典，且“年无分老少，事无分难易，但行之有恒，自如种树畜养，日见其大而不觉耳”！
