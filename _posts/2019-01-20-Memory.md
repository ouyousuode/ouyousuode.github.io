---
layout: post
title: 内存
---
{{page.title}}
======================

## 虚拟内存
对计算机而言，虚拟内存是一种伪造拥有更多(比实际)内存的方式。一台机器可能有4G RAM，但是你可以写一个操纵数倍于此数目内存的程序。当你充满且溢出了实际内存的可用部分后，部分数据被先存储于硬盘，待需要时重新将其读入内存。

操作系统处理数据保存和移动操作的底层繁琐细节。正于物理内存被处理的是保存的数据，而移动的数据是有段时间未接触被外置于硬盘中的内容。若程序想再次操作它，系统便将数据从硬盘读回到内存。

操作系统将内存分成页，它是操作系统可处理的一块4k大小的内存区域。当程序请求内存时，系统便给它们页。如果某页被用了，它便被保存在一个“最近使用的页(recently used pages)”列表中。随着程序向系统请求越来越多的内存，那些最不常用(least recently used)的页便被写入硬盘，此举称为分页(paging)或交换(swapping)；先前占用的物理内存便可再用了。iOS没有这种基于硬盘的交换文件，因此在此平台上，你迟早会碰上内存不足的情况！

页可被誊写(written out)到硬盘，随即从不同物理地址读回。始于地址0x5000的一个4k页被誊写到硬盘，然后便将这块内存给了其它程序。程序现在又需要那些始于0x5000地址的数据了；因此，操作系统再从硬盘中读取那些页。但是，始于0x5000地址的那块内存可能正用于第二个程序。为了解决这个问题，虚拟寻址便上场了！

<img src="/images/posts/2019-01-20/virtualMemory.jpg">
Virtual memory显示了实践中的虚拟内存。虚拟地址是一个程序看到的内存地址，并且每个程序有它自己的地址空间。**OS**(结合**CPU**中的硬件)将虚拟地址映射为RAM中一团页的物理地址。程序A和程序B皆有位于0x8000处的一页数据。在物理内存中，A可能居于物理地址0x15020处，而B可能位于0x3150；但是，“地址翻译”使每个程序有它们的数据在0x8000处这样的幻觉。

某程序在特定时间申请的全部内存称为它的虚拟集合(virtual set)。那些实际位于RAM中的物理内存称为它的常驻(内存)集合。二者的区别在于：是否以swap文件存于硬盘，或以包括只读代码段段文件存于硬盘。你可以加锁、固定住内存，如此它便不能被swapped out！有些你绝对不想swapped out的页，比如包含译密码的页；在破译密码前，应使用**mlock()**函数将这些页固定住。

页也可以有权限，像只读、读/写以及可执行。这可帮你避免scribbling over your own code and helps prevent security exploits that try to execute code from a page that is not marked executable.
## 程序的内存模型
Mac OS X进程有一个概念上内存模型；在此模型中，将内存划分成了可执行代码、栈、堆以及其它片的空间，如Unix program memory model所示。

<img src="/images/posts/2019-01-20/unixProgramMemoryModel.jpg">
- Text Segment  可执行程序代码居于此。在程序启动期，代码从硬盘傻姑娘的只读页映射进内存。由于这些页是只读的，它们可在多个进程间共享。所以这些页虽说在物理内存中仅出现一次，但是可共享于多个用户。当然，它们可以在其它进程的虚拟内存中出现。对共享库而言，便更是如此；它们被加载到每个程序中。因为数据只读，内核可循环使用(recycle)这些页，而不必将它们写入交换文件(swapfile)。

- Initialized Data Segment  初始化的全局及静态变量均位于此处；像任意函数外的float pi = 3.1415及函数内部的static int blah = 25。已初始化的数据存储在data segment；也只是拷贝进内存的读/写页，以便程序可对其修改一二。因为内核只是从硬盘读取数据块，加载与初始化全部变量是非常迅速的。没有实质的初始化发生，仅是加载了大块数据。

- Unintialized Data Segment  那些在全局空间却未明确初始化的数据都聚结此处。比如，函数外的int bork及函数内的static char buffer[5000]，此二者在程序启动时均被清零。**OS**对待它们与initialzed data segment有所区别，它们意味着可执行文件中的很多零数据块。仅有data segment的体积大小被记下了！在程序加载期间，操作系统申请足量的空间，然后用0填充。在手册页，也将此称为“bss”段。“bss”来自一条汇编器指令，意味着“block started by symbol”。

- Heap  堆是动态(运行时)申请内存发生的区域。如果**malloc()**40K，此40K便来自此处。

- Program Stack  此为主线程的程序调用栈。和每个函数call的栈帧一样，本地(局部)变量也存在这儿。当一个函数调用其它函数时，在此新函数被调用前，处理器的寄存器状态及其它的协调簿记均需储存下来。当新函数退出后，这些值均需恢复。
利用程序栈进行内存申请(memory allocation)是非常快的。处理器内的寄存器用于暗示栈的底部在何处。栈上的预留空间仅仅涉及添加一个值到此地址，可以是4字节，也或者是4000字节，仅此而已。你不要想着在栈上存储太多内容(stuff)，因为对栈的容量体积有限制。另外，线程拥有有限的栈空间；因为每个线程有它自己的为栈所用的内存块。
