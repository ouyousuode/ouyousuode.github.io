---
layout: post
title: 内存
---
{{page.title}}
======================

## 虚拟内存
对计算机而言，虚拟内存是一种伪造拥有更多(比实际)内存的方式。一台机器可能有4G RAM，但是你可以写一个操纵数倍于此数目内存的程序。当你充满且溢出了实际内存的可用部分后，部分数据被先存储于硬盘，待需要时重新将其读入内存。

操作系统处理数据保存和移动操作的底层繁琐细节。正于物理内存被处理的是保存的数据，而移动的数据是有段时间未接触被外置于硬盘中的内容。若程序想再次操作它，系统便将数据从硬盘读回到内存。

操作系统将内存分成页，它是操作系统可处理的一块4k大小的内存区域。当程序请求内存时，系统便给它们页。如果某页被用了，它便被保存在一个“最近使用的页(recently used pages)”列表中。随着程序向系统请求越来越多的内存，那些最不常用(least recently used)的页便被写入硬盘，此举称为分页(paging)或交换(swapping)；先前占用的物理内存便可再用了。iOS没有这种基于硬盘的交换文件，因此在此平台上，你迟早会碰上内存不足的情况！

页可被誊写(written out)到硬盘，随即从不同物理地址读回。始于地址0x5000的一个4k页被誊写到硬盘，然后便将这块内存给了其它程序。程序现在又需要那些始于0x5000地址的数据了；因此，操作系统再从硬盘中读取那些页。但是，始于0x5000地址的那块内存可能正用于第二个程序。为了解决这个问题，虚拟寻址便上场了！

<img src="/images/posts/2019-01-20/virtualMemory.jpg">
Virtual memory显示了实践中的虚拟内存。虚拟地址是一个程序看到的内存地址，并且每个程序有它自己的地址空间。**OS**(结合**CPU**中的硬件)将虚拟地址映射为RAM中一团页的物理地址。程序A和程序B皆有位于0x8000处的一页数据。在物理内存中，A可能居于物理地址0x15020处，而B可能位于0x3150；但是，“地址翻译”使每个程序有它们的数据在0x8000处这样的幻觉。

某程序在特定时间申请的全部内存称为它的虚拟集合(virtual set)。那些实际位于RAM中的物理内存称为它的常驻(内存)集合。二者的区别在于：是否以swap文件存于硬盘，或以包括只读代码段段文件存于硬盘。你可以加锁、固定住内存，如此它便不能被swapped out！有些你绝对不想swapped out的页，比如包含译密码的页；在破译密码前，应使用**mlock()**函数将这些页固定住。

页也可以有权限，像只读、读/写以及可执行。这可帮你避免scribbling over your own code and helps prevent security exploits that try to execute code from a page that is not marked executable.
## 程序的内存模型
Mac OS X进程有一个概念上内存模型；在此模型中，将内存划分成了可执行代码、栈、堆以及其它片的空间，如Unix program memory model所示。

<img src="/images/posts/2019-01-20/unixProgramMemoryModel.jpg">

