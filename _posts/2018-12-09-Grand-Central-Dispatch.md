---
layout: post
title: Grand Central Dispatch
---
{{page.title}}
=======================

多线程编程时常是非常困难的。你有竞争条件，虽说可通过加锁以修正，但是选取一个恰当锁粒度以阻止所有线程序列化同一个代码路径却非常困难。锁太大，它们会强制序列化；锁太小，则必须重复加锁/解锁。而且并行算法也比串行算法更难以理解，或者至少不像对串行算法那般熟悉。

<img src="/images/posts/2018-12-09/theTraditionalLockingModel.jpg">
上图即展示了一个典型场景。这有多个线程，它们都在等着处理一些敏感的数据结构。通过使用锁，临界区(critical sections)就被序列化了。此后，线程阻塞至锁可用，方才操作这些敏感的数据结构。

Mac OS X 10.6及iOS 4引入了Grand Central Dispatch(GCD),它本质上使用了队列机制。它提供一种从事大块工作且序列化它们的方式，这些大块工作表现为block的形式。But does this undo all the work you have done with threads以充分利用多核的优势吗？纯粹地看，是的！

<img src="/images/posts/2018-12-09/workingWithASerialQueue.jpg">
上图展示了GCD的世界观。你有一个串行队列，这个队列呢控制着对敏感数据结构的访问。操纵数据结构的所有工作仅发生在一个线程中，因此你无需处理加锁事项。通过把工作块(block)放入队列，单个线程即可执行在数据结构上的操作。

如果操作是用后即不理类型，the thread can go off an do more work while the sensitive queue gets drained。如果线程需要等着工作完成，它就可以等待直至工作干完，再做其它事。即使在这种情形下，性能也不比等着一个鹬蚌相争的锁差！实际上，GCD的性能优越性是板上钉钉的。一旦你把工作放入队列(以FIFO/先进先出顺序处理工作流)了，你的工作定能得到处理。非但如此，如果你添加了更多的队列，那你就有更多作并行化的机会。

<img src="/images/posts/2018-12-09/multipleSerialQueues.jpg">
此图展现了两个不同的有队列保护的敏感数据结构及把工作单元放入队列的几个线程。每一个数据结构都是串行化访问且未加锁的。通过一些这样面对队列的数据结构，你可以有很好的程序范围内的并行化实现！Apple称此种结构为"并发性海洋中的串行化小岛(islands of serialization in a sea of concurrency)"。程序可优化多处理器的使用以便充分利用用户机器上的可用多核心。随着时间的推移，相信越来越多的应用会这么做。

个别的程序没有系统级的资源消耗。扩展并发度以最优化使用机器上的可用计算资源需要对硬件有充足的认识。GCD与内核合作，因此，它可从系统层面了解谁在竞争计算资源，以及可合理安排任务以便拥有最大吞吐量。简言之，GCD可以承诺的是：如果你给他工作了，它会确保(合理范围内)尽可能快地执行它们。

Grand Central Dispatch是libdispatch库的营销(marketing)名称，它被内置于OS X C库，并且它的所有公开函数和类型均以dispatch为前缀。你可用任一程序来获取GCD的数据类型及函数，而且还不必牵扯任意额外的库及框架。开始使用GCD的所有条件仅是包含<dispatch/dispatch.h>头文件及调用它的函数。也需特殊的编译器和链接器标志。

GCD整合了Foundation及Core Foundation的runloop架构。运行主线程的runloop抽空(drain)GCD的主队列。如果没在使用runloop，将不得不在主线程上调用dispatch_main()以抽空其主队列。
## GCD术语
GCD任务是需要处理的事务，像渲染一个网页或显示一条来自社交网络的新信息。一个任务是你的应用想要达成的一个个分立目标。任务可依赖其他任务，它们也可被拆分为子任务。任务最终会被拆分为work项(work items)。

work项是需要完成的独立工作块。对网页而言，这些工作将会是解析请求、访问数据库、运行模板引擎以及合并结果等等。

任务构建自work项，work项又被放入队列。当work项运行时，分派(dispatching)发生。当它到达队列首位时，它会被委派给一个线程以使得工作可实际执行。GCD运行于thread(线程)之上的一层抽象。线程就变成了具体的实现细节。
## 队列
Dispatch队列是GCD的基础数据结构。一个队列就是包含work项的一个列表。根据定义，队列以FIFO(先进者先出)的方式排空。GCD维护一个线程池，在池内运行从队列取出的work项。work可被提交为一个block或者一个"函数指针/上下文"对。每个串行队列均由一个全局队列来支持。

这有两种队列，即串行队列和全局队列。串行队列以FIFO方式分派和完成它们的work项。串行队列不会有两个同时执行的不同work项。这也是能串行访问敏感数据之所在。在主线程干活的主队列(main queue)便是一个串行队列。

全局队列以FIFO的顺序处理工作，但是它不能保证工作完成的顺序。实际的工作块(work block)运行在GCD维护的一个线程池内，并且它们会受到来自OS内核的系统级均衡。这有不同优先级(高/high，默认/default，低/low)的三个全局队列。全局队列有高效且无限制的快读。而所谓宽度，即可同时运行的work项。很显然，串行队列的宽度为1.








