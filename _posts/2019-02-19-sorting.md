---
layout: post
title: 排序之Bubblesort、Insertsort及Quicksort
---
{{page.title}}
=========================

在计算机科学中，排序是一种基本的操作。排序算法已然非常成熟，故自己在本文中只提及此三种排序的伪代码展示及代码实现，而不涉及理论分析。其分析的详细细节可参见《算法导论》，讲解得详细之至！

## Bubblesort
---
冒泡排序(Bubblesort)算法是一种流行的排序算法，重复地交换相邻的两个反序元素。望文生义，看到名字就手写了一个实现。

<img src="/images/posts/2019-02-19/bubbleSort_0.jpg">
运行程序，可成功排序。但是，细究代码，发现：

<img src="/images/posts/2019-02-19/bubbleSortVariant.jpg">
虽然可以解决问题，但是确不符要求。我们可以看看冒泡排序的伪代码：

<img src="/images/posts/2019-02-19/bubbleSort.jpg">
理解伪代码的逻辑后，可简单验证，图示如下：

<img src="/images/posts/2019-02-19/bubbleSortExample.jpg">
紧接着，j从9到3找到第二“轻”的元素上浮到位置(j=)2处，依次类推...但是，试想一种情况：对含有10000个数据的数组排序，在执行第100次循环体后，整个数组已成递增排列，但是循环仍继续进行。如此，便浪费了很多时间资源。因此，写代码时需要耍一个小花招，直译后的代码为：

<img src="/images/posts/2019-02-19/bubbleSort_1.png">

## Insertsort
---
插入排序(Insertsort)的工作机理是以大家打牌时整理牌面的过程引入的。在开始摸牌时，我们左手空空，牌面朝下放在桌上。接着，一次从桌上摸起一张牌，并将它插入到左手一把牌中的正确位置上。为了找到这张牌的正确位置，要将它与手中已有的每张牌从右向左地进行比较。如：

<img src="/images/posts/2019-02-19/insertSort.jpg">
无论在什么时候，左手中的牌都是完成排序的，而这些牌原先都是牌桌上那副牌里最顶端的一些牌。如此，便捋顺思路了。

<img src="/images/posts/2019-02-19/insertSort_0.png">
<img src="/images/posts/2019-02-19/insertSort_1.png">

## Quicksort
---
此算法是C.A.R.Hoare于1962年提出的，其论文[**Quicksort**](https://academic.oup.com/comjnl/article/5/1/10/395338)发表在The Computer Journal,Volume 5,Issue 1,1962,Pages 10–16。此排序算法，对包含n个数的输入数组，最坏情况下，输入时间为Θ(n^2)；但是，平均情况下，期望的运行时间为Θ(nlgn)，性能相当好。所以当得“快速”两字，因此也是最佳的实用选择。

它基于分治(divide-and-conquer)方法，将待排序数组分成两个更小规模的数组，然后对它们递归排序。基于此分治思想，对一个典型子数组A[p..r]排序的三个步骤为：
- **分解：** 数组A[p..r]被划分成两个(可能空)子数组A[p...q-1]和A[q+1...r]，使得A[p...q-1]中的每个元素都小于等于A(q)，并且，小于等于A[q+1...r]中的元素。下标q也在这个划分过程中进行计算。
- **解决：** 通过递归调用快速排序，对子数组A[p...q-1]和A[q+1...r]排序。
- **合并：** 因为两个子数组是就地排序的，合并它们并不需要额外操作，即整个数组A[p...r]已排序。

<img src="/images/posts/2019-02-19/quickSort_0.png">
<img src="/images/posts/2019-02-19/quickSortDescription.jpg">
直译代码为：

<img src="/images/posts/2019-02-19/quickSort_1.png">
当然，这只是根据算法思想做出的“玩具型”实现，可以参考开源代码来学习其工业级实现，资源很多，比如Mac操作系统XNU内核源码的[xnu-1456.1.26/bsd/kern/qsort.c](https://opensource.apple.com//source/xnu/xnu-1456.1.26/bsd/kern/qsort.c)。

Brian W.Kernighan老爷子也在《The Practice of Programming》之“Sorting”节介绍了快速排序，描述得简单利落！

<img src="/images/posts/2019-02-19/quickSort_Kernighan.jpeg">
“When this process is finished,the array is in order.Quicksort is fast because once an element is known to be less than the pivot value,we don't have to compare it to any of the big ones;similarly,big ones are not compared to little ones.This makes it much faster than the siple sorting methods such as insertion and bubble sort that compare each element directly to all the others.”如此清晰明了的英文表述，不忍将其翻译为中文；并且给出了一个最简单的版本(但是，当然不是最快的)。

<img src="/images/posts/2019-02-19/quickSort_code_Kernighan.png">
## 接下来
---

- **刷** [LeetCode](https://leetcode.com)
- **学** [MIT 6.006 : Introduction to Algorithms](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/)
- **读** [《Introduction to Algorithms,3rd Edition》](https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844/ref=sr_1_1?keywords=Introduction+to+Algorithms%2C+3rd+Edition&qid=1555831641&s=gateway&sr=8-1)
